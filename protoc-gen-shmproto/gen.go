package main

import (
	"bytes"
	"fmt"
	"log"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

type Generator struct {
	OutputBuffer    bytes.Buffer
	CppBuffer       bytes.Buffer
	helperBuffer    bytes.Buffer
	helperDefBuffer bytes.Buffer

	dumpMessageCursor int
	dumpFileName      string
	dumpCppName       string
	//dumpDescName string
	macroName   string
	msgTypes    map[string]*descriptor.DescriptorProto
	packageName string
	cppNS       string
	//entryClassInfos   []string
}

func (g *Generator) Verify(file *descriptor.FileDescriptorProto) bool {
	return true
}

func (g *Generator) BuildTypeNameMap(file *descriptor.FileDescriptorProto) {
	if nil == g.msgTypes {
		g.msgTypes = make(map[string]*descriptor.DescriptorProto)
	}
	dottedPkg := "." + file.GetPackage()
	for _, msg := range file.MessageType {
		name := dottedPkg + "." + msg.GetName()
		g.msgTypes[name] = msg
		for _, nest := range msg.NestedType {
			g.msgTypes[name+"."+nest.GetName()] = nest
		}
	}
}

func (g *Generator) getDesc(name string) *descriptor.DescriptorProto {
	desc, exist := g.msgTypes[name]
	if exist {
		return desc
	}
	return nil
}

func (g *Generator) NestMarshal(msg *descriptor.DescriptorProto) []byte {
	buf := &bytes.Buffer{}
	data, _ := proto.Marshal(msg)
	buf.Write(data)
	for _, f := range msg.Field {
		fdesc := g.getDesc(f.GetTypeName())
		if nil != fdesc {
			data = g.NestMarshal(fdesc)
			buf.Write(data)
		}
	}
	return buf.Bytes()
}

func (g *Generator) DumpFile() {
	//ioutil.WriteFile(g.dumpFileName, g.OutputBuffer.Bytes(), 0666)
	//ioutil.WriteFile(g.dumpCppName, g.CppBuffer.Bytes(), 0666)
}

func (g *Generator) TypeName(name string) string {
	if len(name) == 0 {
		return name
	}
	if name[0] == '.' {
		name = name[1:]
	}
	ss := strings.Split(name, ".")
	last := ss[len(ss)-1]
	return "Shm" + last
}

func (g *Generator) DumpHeader(pbfile string) {
	pbfile = strings.Replace(pbfile, ".proto", ".pb", -1)
	fname := pbfile
	if strings.Contains(fname, "/") {
		idx := strings.LastIndex(fname, "/")
		fname = fname[idx+1 : len(fname)]
	}
	g.dumpFileName = fname + ".shm.hpp"
	g.dumpCppName = fname + ".shm.cpp"
	g.macroName = strings.ToUpper(pbfile+".shm.hpp") + "_"
	g.macroName = strings.Replace(g.macroName, ".", "_", -1)
	g.macroName = strings.Replace(g.macroName, "/", "_", -1)
	fmt.Fprintf(&g.OutputBuffer, "// Generated by the plugin protoc-gen-shmproto of protocol buffer compiler.  DO NOT EDIT!\n")
	fmt.Fprintf(&g.OutputBuffer, "//  source: %s\n\n", pbfile)

	fmt.Fprintf(&g.OutputBuffer, "#ifndef %s\n", g.macroName)
	fmt.Fprintf(&g.OutputBuffer, "#define %s\n", g.macroName)
	fmt.Fprintf(&g.OutputBuffer, "#include <iosfwd>\n")
	fmt.Fprintf(&g.OutputBuffer, "#include \"mmdata.hpp\"\n")
	fmt.Fprintf(&g.OutputBuffer, "#include \"shm_proto_helper.hpp\"\n")
	cppHeader := pbfile + ".h"
	fmt.Fprintf(&g.OutputBuffer, "#include \"%s\"\n", cppHeader)

	fmt.Fprintf(&g.CppBuffer, "// Generated by the plugin protoc-gen-shmproto of protocol buffer compiler.  DO NOT EDIT!\n")
	fmt.Fprintf(&g.CppBuffer, "//  source: %s\n\n", pbfile)
	fmt.Fprintf(&g.CppBuffer, "#include <iostream>\n")
	fmt.Fprintf(&g.CppBuffer, "#include \"%s\"\n", g.dumpFileName)
	fmt.Fprintf(&g.OutputBuffer, "#include \"shm_proto.hpp\"\n")

}

func (g *Generator) Finish() {
	fmt.Fprintf(&g.OutputBuffer, "#endif /* %s */\n", g.macroName)
}

func (g *Generator) DumpNamespaceBegin(name string) (string, []string) {
	ss := strings.Split(name, ".")
	var tabs []string
	tab := ""

	for _, ns := range ss {
		if len(g.cppNS) > 0 {
			g.cppNS = g.cppNS + "::"
		}
		g.cppNS = g.cppNS + ns
		fmt.Fprintf(&g.OutputBuffer, "%snamespace %s\n%s{\n", tab, ns, tab)
		fmt.Fprintf(&g.CppBuffer, "%snamespace %s\n%s{\n", tab, ns, tab)
		tabs = append(tabs, tab)
		tab = "    " + tab
		if len(g.packageName) == 0 {
			g.packageName = ns
		} else {
			g.packageName = g.packageName + "." + ns
		}
	}
	fmt.Fprintf(&g.helperDefBuffer, "namespace shm_proto{\n")
	fmt.Fprintf(&g.helperBuffer, "namespace shm_proto{\n")

	return tab, tabs
}

func (g *Generator) DumpNamespaceEnd(tabs []string) {
	for i := len(tabs) - 1; i >= 0; i-- {
		fmt.Fprintf(&g.OutputBuffer, "%s}\n", tabs[i])
		fmt.Fprintf(&g.CppBuffer, "%s}\n", tabs[i])
	}
	fmt.Fprintf(&g.helperBuffer, "}\n")
	fmt.Fprintf(&g.helperDefBuffer, "}\n")
	fmt.Fprintf(&g.helperDefBuffer, "#include \"shm_proto_jce_helper.hpp\"\n")
	g.OutputBuffer.ReadFrom(&g.helperDefBuffer)
	g.OutputBuffer.ReadFrom(&g.helperBuffer)
}

func (g *Generator) getBaseFieldType(field *descriptor.FieldDescriptorProto) string {
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		return "double"
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		return "float"
		// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
		// negative values are likely.
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		return "int64_t"
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		return "uint64_t"
		// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
		// negative values are likely.
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		return "int32_t"
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		return "uint64_t"
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		return "uint32_t"
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return "bool"
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return "mmdata::SHMString"
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return "mmdata::SHMString"
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		return "uint32_t"
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		return field.GetTypeName()
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		return "int32_t"
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		return "int64_t"
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		return "int32_t"
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		return "int64_t"
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return g.TypeName(field.GetTypeName())
	default:
		log.Fatalf("Not supported type:%v", field.GetTypeName())
	}
	return ""
}

func (g *Generator) getFieldType(field *descriptor.FieldDescriptorProto) string {
	if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		isMap := false
		buf := &bytes.Buffer{}
		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			desc := g.getDesc(field.GetTypeName())
			if nil != desc && desc.GetOptions().GetMapEntry() {
				keyField, valField := desc.Field[0], desc.Field[1]
				fmt.Fprintf(buf, "mmdata::SHMMap<%s, %s>::Type", g.getBaseFieldType(keyField), g.getBaseFieldType(valField))
				isMap = true
			}
		}
		if !isMap {
			fmt.Fprintf(buf, "mmdata::SHMVector<%s>::Type", g.getBaseFieldType(field))
		}
		return buf.String()
	}
	return g.getBaseFieldType(field)
}

func (g *Generator) withDefaultValue(field *descriptor.FieldDescriptorProto) (string, bool) {
	if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		return "", false
	}
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		return "0.0", true
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		return "0.0", true
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return "false", true
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return "", false
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return "", false
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		return "", false
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		return "", false
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return "0", true
	default:
		log.Fatalf("Not supported type:%v", field.GetTypeName())
	}
	return "", false
}

func isStringField(field *descriptor.FieldDescriptorProto) bool {
	if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		return true
	}
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return true
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return true
	default:
		return false
	}
	return false
}
func isCommonMessage(field *descriptor.FieldDescriptorProto) bool {
	if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		return false
	}
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return true
	default:
		return false
	}
}

func (g *Generator) isComplextType(field *descriptor.FieldDescriptorProto, excludeString bool) bool {
	if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		return true
	}
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		return false
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		return false
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return false
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		if excludeString {
			return false
		}
		return true
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		if excludeString {
			return false
		}
		return true
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		return false
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return true
	default:
		log.Fatalf("Not supported type:%v", field.GetTypeName())
	}
	return false
}

func (g *Generator) dumpFieldType(buf *bytes.Buffer, field *descriptor.FieldDescriptorProto) {
	fmt.Fprintf(buf, g.getFieldType(field))
}

func (g *Generator) DumpMessage(msg *descriptor.DescriptorProto, currentTAB string) error {

	buf := &g.OutputBuffer
	className := g.TypeName(msg.GetName())
	fmt.Fprintf(buf, "%sstruct %s\n", currentTAB, className)
	fmt.Fprintf(buf, "%s{\n", currentTAB)
	fieldTab := currentTAB + "    "
	var fields string

	for i, field := range msg.GetField() {
		fmt.Fprintf(buf, "%s", fieldTab)
		g.dumpFieldType(buf, field)

		fmt.Fprintf(buf, " %s;\n", field.GetName())
		if i != 0 {
			fields = fields + ","
		}
		fields = fields + field.GetName()
	}
	//fmt.Fprintf(buf, "\n%sKCFG_DEFINE_FIELDS(%s)\n", fieldTab, fields)

	//constructor
	fmt.Fprintf(buf, "\n%s%s(const mmdata::CharAllocator& alloc):", fieldTab, className)
	firstInitParam := true
	for _, field := range msg.GetField() {
		if g.isComplextType(field, false) {
			if !firstInitParam {
				fmt.Fprintf(buf, ",")
			}
			fmt.Fprintf(buf, "%s(alloc)", field.GetName())
			firstInitParam = false
		} else {
			defaultInitVal, exist := g.withDefaultValue(field)
			if exist {
				if !firstInitParam {
					fmt.Fprintf(buf, ",")
				}
				fmt.Fprintf(buf, "%s(%s)", field.GetName(), defaultInitVal)
				firstInitParam = false
			}
		}
	}
	fmt.Fprintf(buf, "\n%s{}\n", fieldTab)

	//getTypeName
	fullName := msg.GetName()
	if len(g.packageName) > 0 {
		fullName = g.packageName + "." + msg.GetName()
	}
	methodTab := fieldTab + "    "
	fmt.Fprintf(buf, "\n%svoid ReadFrom(const %s& pb) {", fieldTab, className[3:])
	for _, field := range msg.GetField() {
		if isCommonMessage(field) {
			fmt.Fprintf(buf, "\n%sif(pb.has_%s()){", methodTab, strings.ToLower(field.GetName()))
			fmt.Fprintf(buf, "\n%s    shm_proto::ReadFrom(%s, pb.%s());", methodTab, field.GetName(), strings.ToLower(field.GetName()))

			fmt.Fprintf(buf, "\n%s}", methodTab)
		} else {
			fmt.Fprintf(buf, "\n%sshm_proto::ReadFrom(%s, pb.%s());", methodTab, field.GetName(), strings.ToLower(field.GetName()))
		}

	}
	fmt.Fprintf(buf, "\n%s}\n", fieldTab)

	fmt.Fprintf(buf, "\n%svoid WriteTo(%s& pb)const {", fieldTab, className[3:])
	for _, field := range msg.GetField() {
		if g.isComplextType(field, false) {
			fmt.Fprintf(buf, "\n%sshm_proto::WriteTo(%s, *(pb.mutable_%s()));", methodTab, field.GetName(), strings.ToLower(field.GetName()))
		} else {
			fmt.Fprintf(buf, "\n%spb.set_%s(%s);", methodTab, strings.ToLower(field.GetName()), field.GetName())
		}
	}
	fmt.Fprintf(buf, "\n%s}\n", fieldTab)
	fmt.Fprintf(buf, "\n%sconst void* Field(const std::string& fname)const {", fieldTab)
	for _, field := range msg.GetField() {
		fmt.Fprintf(buf, "\n%sif(fname == \"%s\") return &%s;", methodTab, field.GetName(), field.GetName())
	}
	fmt.Fprintf(buf, "\n%sreturn NULL;", methodTab)
	fmt.Fprintf(buf, "\n%s}\n", fieldTab)

	fmt.Fprintf(buf, "\n%sstatic const char* GetTypeName() { return \"%s\"; }", fieldTab, fullName)
	fmt.Fprintf(buf, "\n%sstatic void* New(mmdata::MMData& mm) { return mm.New<%s>(); }", fieldTab, className)
	fmt.Fprintf(buf, "\n%sstatic void* NewProto() { return new %s; }", fieldTab, className[3:])
	fmt.Fprintf(buf, "\n%sstatic void Destroy(mmdata::MMData& mm, void* p) { mm.Delete((%s*)p); }", fieldTab, className)
	fmt.Fprintf(buf, "\n%sstatic void ReadFromPB(void* shm_data, const void* pb_data) { ((%s*)shm_data)->ReadFrom(*(const %s*)pb_data); }", fieldTab, className, className[3:])
	fmt.Fprintf(buf, "\n%sstatic void WriteToPB(const void* shm_data, void* pb_data) { ((const %s*)shm_data)->WriteTo(*(%s*)pb_data); }", fieldTab, className, className[3:])
	fmt.Fprintf(buf, "\n%sstatic const void* GetField(const void* shm_data, const std::string& fname) {", fieldTab)
	fmt.Fprintf(buf, "\n%sreturn ((const %s*)shm_data)->Field(fname);", methodTab, className)
	fmt.Fprintf(buf, "\n%s}\n", fieldTab)
	fmt.Fprintf(buf, "\n%sstatic void* GetPBWriteField(void* pb_data, const std::string& fname) {", fieldTab)
	fmt.Fprintf(buf, "\n%s%s* pb = (%s*)pb_data;", methodTab, className[3:], className[3:])
	for _, field := range msg.GetField() {
		if isCommonMessage(field) {
			fmt.Fprintf(buf, "\n%sif(fname == \"%s\") return pb->mutable_%s();", methodTab, field.GetName(), strings.ToLower(field.GetName()))
		}
	}
	fmt.Fprintf(buf, "\n%sreturn NULL;", methodTab)
	fmt.Fprintf(buf, "\n%s}\n", fieldTab)

	fmt.Fprintf(buf, "%s};\n\n", currentTAB)

	fmt.Fprintf(buf, "%sinline std::ostream& operator<<(std::ostream& os, const %s& v)\n", currentTAB, className)
	funcTab := currentTAB + "    "
	fmt.Fprintf(buf, "%s{\n", currentTAB)
	fmt.Fprintf(buf, "%sos<<\"[%s:\";\n", funcTab, className)
	for i, field := range msg.GetField() {
		if i > 0 {
			fmt.Fprintf(buf, "%sos<<\",%s=\"<< v.%s;\n", funcTab, field.GetName(), field.GetName())
		} else {
			fmt.Fprintf(buf, "%sos<<\"%s=\"<< v.%s;\n", funcTab, field.GetName(), field.GetName())
		}
	}
	fmt.Fprintf(buf, "%sos<<\"]\";\n", funcTab)
	fmt.Fprintf(buf, "%sreturn os;\n", funcTab)
	fmt.Fprintf(buf, "%s}\n\n", currentTAB)

	fmt.Fprintf(&g.helperDefBuffer, "%stemplate<typename JCE>\n", currentTAB)
	fmt.Fprintf(&g.helperDefBuffer, "%sinline void Jce2Proto(const JCE& jce, %s::%s& pb);\n", currentTAB, g.cppNS, className[3:])

	fmt.Fprintf(&g.helperBuffer, "%stemplate<typename JCE>\n", currentTAB)
	fmt.Fprintf(&g.helperBuffer, "%sinline void Jce2Proto(const JCE& jce, %s::%s& pb){", currentTAB, g.cppNS, className[3:])
	for _, field := range msg.GetField() {
		if g.isComplextType(field, false) {
			if field.GetLabel() != descriptor.FieldDescriptorProto_LABEL_REPEATED && (descriptor.FieldDescriptorProto_TYPE_BYTES == field.GetType() || descriptor.FieldDescriptorProto_TYPE_STRING == field.GetType()) {
				fmt.Fprintf(&g.helperBuffer, "\n%sif(!jce.%s.empty()) Jce2Proto(jce.%s, *(pb.mutable_%s()));", funcTab, field.GetName(), field.GetName(), strings.ToLower(field.GetName()))
			} else {
				fmt.Fprintf(&g.helperBuffer, "\n%sJce2Proto(jce.%s, *(pb.mutable_%s()));", funcTab, field.GetName(), strings.ToLower(field.GetName()))
			}
		} else {
			fmt.Fprintf(&g.helperBuffer, "\n%sif(0 != jce.%s) pb.set_%s(jce.%s);", funcTab, field.GetName(), strings.ToLower(field.GetName()), field.GetName())
		}
	}
	fmt.Fprintf(&g.helperBuffer, "\n%s}\n\n", currentTAB)

	fmt.Fprintf(&g.helperDefBuffer, "%stemplate<typename JCE>\n", currentTAB)
	fmt.Fprintf(&g.helperDefBuffer, "%sinline void ShmProto2Jce(const %s::%s& shm, JCE& jce);\n", currentTAB, g.cppNS, className)
	fmt.Fprintf(&g.helperBuffer, "%stemplate<typename JCE>\n", currentTAB)
	fmt.Fprintf(&g.helperBuffer, "%sinline void ShmProto2Jce(const %s::%s& shm, JCE& jce){", currentTAB, g.cppNS, className)
	for _, field := range msg.GetField() {
		if g.isComplextType(field, false) {
			fmt.Fprintf(&g.helperBuffer, "\n%sShmProto2Jce(shm.%s, jce.%s);", funcTab, field.GetName(), field.GetName())
		} else {
			fmt.Fprintf(&g.helperBuffer, "\n%sjce.%s = shm.%s;", funcTab, field.GetName(), field.GetName())
		}
	}
	fmt.Fprintf(&g.helperBuffer, "\n%s}\n\n", currentTAB)

	fmt.Fprintf(&g.CppBuffer, "%sstatic shm_proto::ShmProtoRegister<%s> instance_%d;\n", currentTAB, className, g.dumpMessageCursor)

	g.dumpMessageCursor++

	return nil
}
